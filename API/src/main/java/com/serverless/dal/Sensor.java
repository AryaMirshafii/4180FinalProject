package com.serverless.dal;

import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.datamodeling.*;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.TableNameOverride;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.log4j.Priority;

import javax.ws.rs.NotFoundException;

@DynamoDBTable(tableName = "SENSOR_TABLE_NAME")
public class Sensor {
    private static final String SENSOR_TABLE_NAME = System.getenv("SENSOR_TABLE_NAME");
    private static final String DATA_TABLE_NAME = System.getenv("DATA_TABLE_NAME");
    private static DynamoDBAdapter db_adapter;
    private final AmazonDynamoDB client;
    private final DynamoDBMapper sensorMapper;
    private final DynamoDBMapper dataMapper;
    private Logger logger = Logger.getLogger(this.getClass());

    //Sensor data

    private String id;
    private String name;
    private double currentHumidity = 0;
    private double currentTemperature = 0;

    private double currentHallEffect = 0;
    private boolean motionDetected = false;


    private double currentAccelerationX = 0;
    private double currentAccelerationY = 0;
    private double currentAccelerationZ = 0;

    private List<String> roomIdList = new ArrayList<>();


    @DynamoDBHashKey(attributeName = "id")
    @DynamoDBAutoGeneratedKey
    public String getId() {
        return this.id;
    }
    public void setId(String id) {

        this.id = id;
    }


    @DynamoDBAttribute(attributeName = "name")
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }


    @DynamoDBAttribute(attributeName = "currentHumidity")
    public double getCurrentHumidity() {
        return this.currentHumidity;
    }
    public void setCurrentHumidity(double currentHumidity) {

        this.currentHumidity = currentHumidity;
    }


    @DynamoDBAttribute(attributeName = "currentTemperature")
    public double getCurrentTemperature() {
        return this.currentTemperature;
    }
    public void setCurrentTemperature(double currentTemperature) {

        this.currentTemperature = currentTemperature;
    }


    @DynamoDBAttribute(attributeName = "currentHallEffect")
    public double getCurrentHallEffect() {
        return this.currentHallEffect;
    }
    public void setCurrentHallEffect(double currentHallEffect) {

        this.currentHallEffect = currentHallEffect;
    }


    @DynamoDBAttribute(attributeName = "motionDetected")
    public boolean getMotionDetected() {
        return this.motionDetected;
    }
    public void setMotionDetected(boolean motionDetected) {

        this.motionDetected = motionDetected;
    }


    @DynamoDBAttribute(attributeName = "currentAccelerationX")
    public double getCurrentAccelerationX() {
        return this.currentAccelerationX;
    }
    public void setCurrentAccelerationX(double currentAccelerationX) {

        this.currentAccelerationX = currentAccelerationX;
    }


    @DynamoDBAttribute(attributeName = "currentAccelerationY")
    public double getCurrentAccelerationY() {
        return this.currentAccelerationY;
    }
    public void setCurrentAccelerationY(double currentAccelerationY) {

        this.currentAccelerationY = currentAccelerationY;
    }


    @DynamoDBAttribute(attributeName = "currentAccelerationZ")
    public double getCurrentAccelerationZ() {
        return this.currentAccelerationZ;
    }
    public void setCurrentAccelerationZ(double currentAccelerationZ) {

        this.currentAccelerationZ = currentAccelerationZ;
    }


    public Sensor() {
        DynamoDBMapperConfig mapperConfig = DynamoDBMapperConfig.builder()
                .withTableNameOverride(new DynamoDBMapperConfig.TableNameOverride(SENSOR_TABLE_NAME))
                .build();
        // get the db adapter
        this.db_adapter = DynamoDBAdapter.getInstance();
        this.client = this.db_adapter.getDbClient();
        // create the mapper with config
        this.sensorMapper = this.db_adapter.createDbMapper(mapperConfig);


        DynamoDBMapperConfig roomMapperConfig = DynamoDBMapperConfig.builder()
                .withTableNameOverride(new DynamoDBMapperConfig.TableNameOverride(DATA_TABLE_NAME))
                .build();
        // get the db adapter

        // create the mapper with config
        this.dataMapper = this.db_adapter.createDbMapper(roomMapperConfig);
    }

    public String toString() {
        return String.format("Sensor [ID=%s, Name=%s, Humidity=%s, Temperature=%s, AccelerationX=%s, AccelerationY=%s, AccelerationZ=%s ,Hall Effect= %s]",
                this.id, this.name, this.currentHumidity, this.currentTemperature, this.currentAccelerationX, this.currentAccelerationY, this.currentAccelerationZ, this.currentHallEffect);
    }


    public void save(Sensor sensor) throws IOException {
        logger.info("Sensor - save(): " + sensor.toString());
        this.sensorMapper.save(sensor);

    }

    public boolean sensorExists(String sensorId, String sensorName) {
        Sensor sensorById;
        Sensor sensorByName;
        try {
            sensorById = get(sensorId);
            sensorByName = getByName(sensorName);
        } catch (IOException e) {

            e.printStackTrace();
            return false;
        }

        return sensorById != null || sensorByName != null;
    }

    public void updateData(SensorData data) throws IOException {
        Sensor parent = null;
        data.setSensorId("Data sensor id is" + data.getSensorId());

        data.save(data);
        //logger.log(Priority.DEBUG,"Data sensor id is" + data.getSensorId());
        //logger.log(Priority.DEBUG,"Data sensorName is" + data.getSensorName());

        if(data.getSensorId() != null && !data.getSensorId().isEmpty()){
            try {
                String sensorId =  data.getSensorId().trim();
                sensorId= sensorId.replaceAll("\\\\", "");
                parent  = get(sensorId);

            } catch (IOException e) {
                e.printStackTrace();
            }

        }else if(data.getSensorName() != null &&  !data.getSensorName().isEmpty()){
            try {
                String sensorName =  data.getSensorName().trim();
                sensorName = sensorName.replaceAll("\\\\", "");
                parent  = getByName(sensorName);
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

        if(parent == null){
            return;
        }

        parent.setCurrentTemperature(69);
        parent.setCurrentHumidity(69);
        //parent.setCurrentAcceleration(69);
        parent.save(parent);

        /*

        if(parent == null){
            logger.log(Priority.ERROR, " The sensor does not exist");
            return;
        }

        switch (data.getDataType().toLowerCase()){
            case "temperature":
                parent.setCurrentTemperature(data.getData());
                parent.save(parent);
                break;
            case "humidity":
                parent.setCurrentHumidity(data.getData());
                parent.save(parent);
                break;
            case "acceleration":
                parent.setCurrentAcceleration(data.getData());
                parent.save(parent);
                break;
            case "halleffect":
                parent.setCurrentHallEffect(data.getData());
                parent.save(parent);
                break;
            default:
                logger.log(Priority.ERROR, "Unrecognized data type");
        }

         */
    }

    public Sensor getByName(String nameNumber) throws IOException {
        List<Sensor> sensors = list();

        for(Sensor sensor: sensors){
            if(sensor.name.equals(nameNumber)){
                return sensor;
            }
            if(getLongestCommonSubstring(sensor.name, nameNumber) > 10){
                return sensor;
            }
        }

        throw new NotFoundException("The sensor with the given name number does not exist");
    }

    public Sensor get(String id) throws IOException {
        Sensor sensor = null;

        HashMap<String, AttributeValue> av = new HashMap<String, AttributeValue>();
        av.put(":v1", new AttributeValue().withS(id));

        DynamoDBQueryExpression<Sensor> queryExp = new DynamoDBQueryExpression<Sensor>()
                .withKeyConditionExpression("id = :v1")
                .withExpressionAttributeValues(av);

        PaginatedQueryList<Sensor> result = this.sensorMapper.query(Sensor.class, queryExp);
        if (result.size() > 0) {
            sensor = result.get(0);
            logger.info("Sensor - get(): sensor - " + sensor.toString());
        } else {
            logger.info("Sensor - get(): sensor - Not Found.");
        }
        return sensor;
    }


    public static int getLongestCommonSubstring(String a, String b){
        int m = a.length();
        int n = b.length();

        int max = 0;

        int[][] dp = new int[m][n];

        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(a.charAt(i) == b.charAt(j)){
                    if(i==0 || j==0){
                        dp[i][j]=1;
                    }else{
                        dp[i][j] = dp[i-1][j-1]+1;
                    }

                    if(max < dp[i][j])
                        max = dp[i][j];
                }

            }
        }

        return max;
    }




    public Boolean delete(String id) throws IOException {
        Sensor sensor = null;

        // get product if exists
        sensor = get(id);
        if (sensor != null) {
            logger.info("Sensor - delete(): " + sensor.toString());
            this.sensorMapper.delete(sensor);
        } else {
            logger.info("Sensors - delete(): sensor - does not exist.");
            return false;
        }
        return true;
    }

    public List<Sensor> list() throws IOException {
        DynamoDBScanExpression scanExp = new DynamoDBScanExpression();
        List<Sensor> results = this.sensorMapper.scan(Sensor.class, scanExp);
        for (Sensor sensor : results) {
            logger.info("Sensor - list(): " + sensor.toString());
        }
        return results;
    }
}
